System Architecture — Local Cache + R2 + Render (Final Integration, No Compression)

Local Cache: IndexedDB Mirroring with Temporal Keys

Each file is uniquely identified by its temporal coverage, not just date.
No compression is used locally — the data remains raw Int16 or Int32 for instant read and low CPU overhead.

/data/{YEAR}/{MONTH}/{NETWORK}/{VOLCANO}/{STATION}/{LOCATION}/{CHANNEL}/{START}_to_{END}.bin

Example:

/data/2025/10/HV/kilauea/NPOC/01/HHZ/2025-10-24-00-00-00_to_2025-10-24-00-10-00.bin

Key (in IndexedDB):
A string of the full path above — deterministic, human-readable, range-aware.

Value object stored:

{
  meta: {
    start: "2025-10-24T00:00:00Z",
    end: "2025-10-24T00:10:00Z",
    year: 2025,
    month: 10,
    network: "HV",
    volcano: "kilauea",
    station: "NPOC",
    location: "01",
    channel: "HHZ",
    byteLength: 1440000,
    format: "int16",
    sampleRate: 100,
    createdAt: Date.now()
  },
  data: ArrayBuffer
}

Behavior:
	1.	On user request, browser queries IndexedDB for overlapping time ranges.
	•	If [requestedStart, requestedEnd] fully covered → assemble locally.
	•	If partial → play what exists, request missing segments from R2.
	•	Stitch contiguous segments in memory by sorting on meta.start.
	2.	New data from R2 gets written into IndexedDB immediately with its {START}_to_{END} key.
	3.	Eviction or missing spans are handled naturally — filenames are self-describing and sortable.

Why no compression locally:
	•	Browser CPU overhead for gzip inflate/deflate is non-trivial on large files.
	•	IndexedDB storage is cheap and async; disk I/O is faster than recompression.
	•	Raw binary allows zero-copy decoding for playback.
	•	Faster seeking, merging, and visualization — no waiting on decompression threads.

⸻

R2 Worker: The Orchestrator

R2 Worker remains the single routing layer between browser and backend.

Flow:
	1.	Browser requests time range:

/data?network=HV&volcano=kilauea&station=NPOC&channel=HHZ&start=2025-10-24T00:00:00Z&end=2025-10-24T00:10:00Z


	2.	Worker checks R2 for existing file.
	•	If found → stream to client directly.
	•	If not → forward to Render for generation.
	3.	Worker sets headers describing what’s being sent:

X-Data-Start: 2025-10-24T00:00:00Z
X-Data-End: 2025-10-24T00:10:00Z
X-Channel: HHZ
X-Format: int32

Browser uses these to label its local cache entry.

	4.	Worker stores completed file back to R2 for future reuse.

⸻

Render: Heavy Processing Layer

Render is called only on cache misses.
Handles all pre-processing and stores final data on R2.

Responsibilities:
	•	Fetch raw SEED data from IRIS.
	•	Convert to int32 for full fidelity.
	•	Apply:
	•	High-pass filter (~20 Hz)
	•	Instrument correction (IR convolution)
	•	Normalization
	•	Quantize to int16 for serving if dynamic range allows.
	•	Upload uncompressed .bin file to R2 with canonical temporal filename.

All local and remote filenames share the same structure, ensuring direct mirroring.

⸻

Local–Remote Coordination Logic

When the user scrubs or requests new time ranges:
	1.	Browser checks IndexedDB for overlapping segments.
	2.	If full coverage → assemble and play immediately.
	3.	If partial → begin playback with local data, request missing segments from R2.
	4.	As R2 responses arrive:
	•	Append each segment to IndexedDB with full path key.
	•	Merge segments in memory.
	•	Continue playback seamlessly.

Each file’s meta.start and meta.end define continuity — no extra manifest needed.

⸻

Playback Start Logic
	•	Begin playback once ≥ 1 second of continuous audio is available locally or from R2.
	•	Worker ensures chunks stream progressively so playback can begin within ~200–300 ms.
	•	If R2 must call Render, playback still starts early with first returned bytes, filling gaps as chunks arrive.

⸻

Rationale for Time-Based Keys (No Compression)
	•	Each file represents a precise time span — unique by definition.
	•	Sorting by key == sorting by time — trivial to merge sequences.
	•	Readable paths simplify debugging and visualization.
	•	Avoiding compression eliminates CPU and I/O overhead in the browser.
	•	IndexedDB read/write of raw ArrayBuffer is fast enough for real-time use.

⸻

Summary Table

Layer	Role	Key	Compression	Strengths
IndexedDB (Browser)	Local cache for user-accessed chunks	/.../{START}_to_{END}.bin	None	Immediate access, low CPU load, full fidelity
R2 Worker	Edge orchestrator + cache	same	Optional (gzip/zstd)	Manages fetch, stream, and storage decisions
Render	Preprocessor + IRIS integration	same	Optional (gzip/zstd)	Heavy compute and preprocessing tasks


⸻

End-to-End Flow

Browser
  → IndexedDB lookup
      → hit → play
      → partial → play + request missing segments
          → R2 Worker
              → hit → stream from R2
              → miss → request from Render
                     → fetch from IRIS
                     → preprocess, upload to R2
                     → R2 streams to browser + stores


⸻

Future Steps
	•	Manifest endpoint on R2 for chunk existence checks.
	•	Local continuity checker for combining partial files.
	•	Optional garbage collection in IndexedDB based on createdAt.
	•	Progressive waveform rendering using available chunks for instant visuals.
	•	Optional local “warm” cache limit (e.g., last 48 hours) before pruning.

⸻

This architecture keeps the browser’s cache lightweight, direct, and synchronized with R2 — fully deterministic by time range, zero compression overhead, and structured for sub-300 ms interactive audio streaming.